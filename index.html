<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no" />
  <title>Mixed Reality + VR Estéreo (Cardboard Forçado)</title>

  <style>
    html,body{height:100%;margin:0;background:#000;overflow:hidden}
    #ui{position:fixed;left:12px;top:12px;z-index:20;color:#fff;font-family:system-ui,Arial}
    button{font-size:16px;padding:8px 12px;margin:6px}
    #score{font-weight:700;margin-left:8px}
    video#cam{position:fixed;inset:0;width:100%;height:100%;object-fit:cover;z-index:0}
    canvas#vr-canvas{position:fixed;inset:0;width:100%;height:100%;z-index:2;pointer-events:auto}
    .hint{opacity:.9;font-size:13px;margin-top:6px}
  </style>

  <!-- WEBXR POLYFILL PARA SIMULAR VR EM CELULARES SEM SUPORTE -->
  <script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>

  <!-- VRButton compatível com polyfill -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/examples/jsm/webxr/VRButton.js"></script>

  <script>
    /* Força WebXR mesmo quando o celular não tem headset */
    const polyfill = new WebXRPolyfill({
      cardboardConfig: {
        VRDisplays: "force",
        provideFakeOrientation: true
      }
    });

    /* Garante que navigator.xr existe */
    if (!navigator.xr) {
      navigator.xr = {
        isSessionSupported: async () => true,
        requestSession: async () => ({
          end: async () => {},
          requestReferenceSpace: async () => ({}),
          updateRenderState: () => {},
          inputs: []
        })
      };
    }
  </script>
</head>

<body>

  <div id="ui">
    <button id="start-stereo">VR Estéreo</button>
    <button id="start-fallback">Somente Câmera</button>
    <div class="hint">Toque para atirar</div>
    <div class="hint">Placar: <span id="score">0</span></div>
    <div class="hint" id="notes"></div>
  </div>

  <video id="cam" autoplay playsinline muted></video>
  <canvas id="vr-canvas"></canvas>

  <script src="https://cdn.jsdelivr.net/npm/three@0.159.0/build/three.min.js"></script>

  <script>
  /***********************
   CONFIGURAÇÕES GERAIS
  ***********************/
  const notes = document.getElementById('notes');
  const scoreEl = document.getElementById('score');
  const video = document.getElementById('cam');
  const canvas = document.getElementById('vr-canvas');
  const startStereoBtn = document.getElementById('start-stereo');
  const startFallbackBtn = document.getElementById('start-fallback');

  let renderer, scene, cameraL, cameraR;
  let W = window.innerWidth, H = window.innerHeight;
  let dpr = Math.min(window.devicePixelRatio || 1, 2);
  let score = 0;
  const IPD = 0.065;

  /***********************
   INICIAR CÂMERA
  ***********************/
  async function startCamera(){
    try{
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'environment' },
        audio: false
      });
      video.srcObject = stream;
      await video.play();
      return true;
    }catch(err){
      notes.innerText = 'Erro ao acessar câmera: ' + err;
      return false;
    }
  }

  /***********************
    INICIALIZAR THREE
  ***********************/
  function initThree(){
    renderer = new THREE.WebGLRenderer({ canvas, alpha: true, antialias: true });
    renderer.setClearColor(0x000000, 0);
    renderer.setPixelRatio(dpr);
    renderer.setSize(W, H, false);

    scene = new THREE.Scene();

    // Luzes
    scene.add(new THREE.HemisphereLight(0xffffff, 0x666666, 1));
    scene.add(new THREE.AmbientLight(0xffffff, 0.3));

    // Alvos
    for(let i=0;i<6;i++){
      const m = new THREE.Mesh(
        new THREE.SphereGeometry(0.06, 16, 12),
        new THREE.MeshStandardMaterial({ color: 0xff6b6b })
      );
      m.position.set((Math.random()-0.5)*1.2, (Math.random()-0.3)*0.5, -0.8 - Math.random()*1.2);
      m.userData.floatSpeed = 0.002 + Math.random()*0.004;
      scene.add(m);
    }
  }

  /***********************
    CÂMERAS ESQUERDA/DIREITA
  ***********************/
  function setupCameras(){
    const fov = 70;
    cameraL = new THREE.PerspectiveCamera(fov, (W/2)/H, 0.01, 50);
    cameraR = new THREE.PerspectiveCamera(fov, (W/2)/H, 0.01, 50);

    cameraL.position.set(-IPD/2, 0, 0);
    cameraR.position.set(IPD/2, 0, 0);

    const center = new THREE.Vector3(0,0,-1);
    cameraL.lookAt(center);
    cameraR.lookAt(center);
  }

  function resizeAll(){
    W = window.innerWidth;
    H = window.innerHeight;

    renderer.setSize(W, H, false);
    cameraL.aspect = (W/2)/H;
    cameraR.aspect = (W/2)/H;
    cameraL.updateProjectionMatrix();
    cameraR.updateProjectionMatrix();
  }

  /***********************
       LOOP DE RENDER
  ***********************/
  function animate(){
    const t = performance.now();

    scene.traverse(o=>{
      if(o.userData.floatSpeed){
        o.position.y += Math.sin(t * o.userData.floatSpeed) * 0.0007;
      }
    });

    // esquerda
    renderer.setViewport(0, 0, W/2, H);
    renderer.setScissor(0, 0, W/2, H);
    renderer.setScissorTest(true);
    renderer.render(scene, cameraL);

    // direita
    renderer.setViewport(W/2, 0, W/2, H);
    renderer.setScissor(W/2, 0, W/2, H);
    renderer.setScissorTest(true);
    renderer.render(scene, cameraR);

    renderer.setAnimationLoop(animate);
  }

  /***********************
       TOQUE / RAYCAST
  ***********************/
  function onPointer(ev){
    ev.preventDefault();
    const rect = canvas.getBoundingClientRect();
    const clientX = ev.touches ? ev.touches[0].clientX : ev.clientX;
    const half = (clientX - rect.left) < (rect.width/2) ? 'left' : 'right';

    const cam = half === 'left' ? cameraL : cameraR;
    const ndcX = ((clientX - rect.left) / (rect.width/2)) * 2 - 1;
    const ndcY = -((ev.touches ? ev.touches[0].clientY : ev.clientY) / rect.height) * 2 + 1;

    const ray = new THREE.Raycaster();
    ray.setFromCamera({x: ndcX, y: ndcY}, cam);
    const hits = ray.intersectObjects(scene.children);

    if(hits.length){
      scene.remove(hits[0].object);
      score++;
      scoreEl.textContent = score;
    }
  }

  /***********************
     MODO VR ESTÉREO
  ***********************/
  async function startStereo(){
    const ok = await startCamera();
    if(!ok) return;

    // Forçar XR
    renderer.xr.enabled = true;
    renderer.xr.setFramebufferScaleFactor(1.0);

    // Botão VR
    const btn = VRButton.createButton(renderer, {
      requiredFeatures: [],
      optionalFeatures: ['local-floor'],
      forceStereo: true
    });
    document.body.appendChild(btn);

    // Fullscreen
    if(document.documentElement.requestFullscreen){
      try { await document.documentElement.requestFullscreen(); } catch(e){}
    }

    initThree();
    setupCameras();

    canvas.addEventListener('touchstart', onPointer, {passive:false});
    canvas.addEventListener('mousedown', onPointer, {passive:false});

    window.addEventListener('resize', resizeAll);

    notes.innerText = "VR Estéreo Forçado — pronto para usar no VR Box.";

    animate();
  }

  async function startFallback(){
    await startCamera();
    notes.innerText = "Modo câmera (sem VR).";
  }

  startStereoBtn.addEventListener('click', startStereo);
  startFallbackBtn.addEventListener('click', startFallback);

  </script>
</body>
</html>
