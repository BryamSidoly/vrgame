<!doctype html>
<html lang="pt-BR">
<head>
  <meta charset="utf-8" />
  <title>AR com Hit-test + Depth (Exemplo)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover" />
  <style>
    html,body { height:100%; margin:0; overflow:hidden; background:#000; color:#fff; font-family: Arial, sans-serif; }
    #score { position: absolute; top:10px; right:10px; z-index:2;
             background: rgba(0,0,0,0.5); padding:6px 10px; border-radius:6px; }
    #info { position:absolute; left:10px; top:10px; z-index:2;
           background: rgba(0,0,0,0.5); padding:6px 10px; border-radius:6px; max-width:55%; }
    #startHint { position:absolute; left:50%; top:50%; transform:translate(-50%,-50%); z-index:2;
                 background: rgba(0,0,0,0.6); padding:12px 18px; border-radius:8px; }
    button { font-size:16px; padding:8px 12px; border-radius:6px; }
  </style>
</head>
<body>
  <div id="info">Toque na tela sobre o retículo para colocar cubos. Mire (gaze) no cubo para removê-lo.</div>
  <div id="score">Score: 0</div>
  <div id="startHint">Use o botão "Enter AR" que aparecerá (requer Chrome/Android com ARCore)</div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/webxr/ARButton.js';

    let camera, scene, renderer;
    let reticle;
    let hitTestSource = null;
    let hitTestSourceRequested = false;
    let cubes = [];
    let score = 0;
    const raycaster = new THREE.Raycaster();

    // Info UI
    const scoreEl = document.getElementById('score');
    const startHint = document.getElementById('startHint');

    init();
    animate();

    function init() {
      scene = new THREE.Scene();

      camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setPixelRatio(window.devicePixelRatio);
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.xr.enabled = true;
      document.body.appendChild(renderer.domElement);

      // ARButton com depth-sensing requisitado.
      // depthSensing: { usagePreference, dataFormatPreference } pode ajudar navegadores a escolher formato.
      const depthOptions = {
        usagePreference: ["cpu-optimized"],
        dataFormatPreference: ["luminance-alpha"]
      };

      document.body.appendChild(ARButton.createButton(renderer, {
        requiredFeatures: ['hit-test', 'depth-sensing'],
        optionalFeatures: ['dom-overlay', 'local-floor', 'bounded-floor'],
        domOverlay: { root: document.body },
        depthSensing: depthOptions
      }));

      // Luz simples
      const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
      scene.add(light);

      // Retículo (ring) que aparece sobre a superfície detectada
      const ringGeo = new THREE.RingGeometry(0.08, 0.11, 32).rotateX(-Math.PI / 2);
      const ringMat = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
      reticle = new THREE.Mesh(ringGeo, ringMat);
      reticle.matrixAutoUpdate = false;
      reticle.visible = false;
      scene.add(reticle);

      // Sombra projetada (simples) - um plano transparente que segue o reticle quando usar
      const shadowGeo = new THREE.PlaneGeometry(0.6, 0.6);
      const shadowMat = new THREE.MeshBasicMaterial({ color: 0x000000, transparent: true, opacity: 0.25 });
      const shadowPlane = new THREE.Mesh(shadowGeo, shadowMat);
      shadowPlane.rotateX(-Math.PI / 2);
      shadowPlane.visible = false;
      shadowPlane.name = "shadowPlane";
      scene.add(shadowPlane);

      // Clique/tap para colocar cubo (quando reticle visível)
      renderer.domElement.addEventListener('click', (ev) => {
        if (reticle.visible) {
          const pos = new THREE.Vector3();
          pos.setFromMatrixPosition(reticle.matrix);
          addCubeAt(pos);
        }
      });

      // resize
      window.addEventListener('resize', onWindowResize);

      // Remover cube por gaze (olhar no centro)
      // Também suportamos toque longo se quiser futuramente.
    }

    function onWindowResize() {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    }

    // Adiciona cubo com pequena animação
    function addCubeAt(worldPos) {
      const size = 0.18 + Math.random() * 0.12;
      const geom = new THREE.BoxGeometry(size, size, size);
      const mat = new THREE.MeshStandardMaterial({ color: new THREE.Color().setHSL(Math.random(), 0.6, 0.5) });
      const cube = new THREE.Mesh(geom, mat);
      cube.castShadow = true;

      cube.position.copy(worldPos);
      cube.position.y += size / 2; // sobe para ficar sobre a superfície
      scene.add(cube);
      cubes.push(cube);
      // update score? only when removed
    }

    // Função utilitária para tentar ler depth info do XRFrame para uma coordenada NDC [-1,1]
    // Retorna distância em metros ou null.
    function sampleDepthAt(frame, normalizedX, normalizedY) {
      // Precisamos de session, reference space e views
      const session = renderer.xr.getSession();
      if (!session) return null;

      // Ao trabalhar com multiscreen/VR, usamos a primeira view (normalmente a única no AR)
      const pose = frame.getViewerPose(renderer.xr.getReferenceSpace ? renderer.xr.getReferenceSpace() : null);
      if (!pose || !pose.views || pose.views.length === 0) return null;
      const view = pose.views[0];

      // Tenta pegar depth info para a view
      let depthInfo = null;
      try {
        depthInfo = frame.getDepthInformation(view);
      } catch (e) {
        // getDepthInformation pode lançar se não suportado
        depthInfo = null;
      }
      if (!depthInfo) return null;

      // depthInfo: tem width,height, data, rawValueToMeters (dependendo do impl)
      const width = depthInfo.width;
      const height = depthInfo.height;

      // Converter normalized coords [-1,1] para pixel coords no depth map
      const px = Math.floor((normalizedX * 0.5 + 0.5) * width);
      const py = Math.floor((normalizedY * 0.5 + 0.5) * height);
      const clampedX = Math.min(Math.max(px, 0), width - 1);
      const clampedY = Math.min(Math.max(py, 0), height - 1);

      // A API real pode expor depthInfo.data como TypedArray view
      // Tenta várias abordagens defensivas
      let data = null;
      try {
        if (depthInfo.data) {
          // depthInfo.data pode ser an ArrayBufferView (e.g., Uint16Array or Float32Array)
          data = depthInfo.data;
        } else if (depthInfo.image) {
          // Em algumas implementações, depthInfo.image existe -> não lidamos com isso aqui
          return null;
        } else {
          return null;
        }
      } catch (e) {
        return null;
      }

      // Tentar deduzir como extrair valor:
      // - Se for Float32Array, cada pixel é 1 valor (meters)
      // - Se for Uint16Array, pode precisar multiplicar por rawValueToMeters
      let idx = clampedY * width + clampedX;
      let valMeters = null;

      if (data instanceof Float32Array) {
        valMeters = data[idx]; // já em metros (provável)
      } else if (data instanceof Uint16Array) {
        if (typeof depthInfo.rawValueToMeters === 'number') {
          valMeters = data[idx] * depthInfo.rawValueToMeters;
        } else {
          // tentativa genérica: tratar como mm -> converter para metros
          valMeters = data[idx] / 1000;
        }
      } else if (data.BYTES_PER_ELEMENT) {
        // tenta interpretar via buffer como Float32Array
        try {
          const floatView = new Float32Array(data.buffer || data);
          valMeters = floatView[idx];
        } catch (e) {
          valMeters = null;
        }
      } else {
        valMeters = null;
      }

      if (typeof valMeters !== 'number' || !isFinite(valMeters) || valMeters <= 0) return null;
      return valMeters;
    }

    // Remove cube (com atualização de score)
    function removeCube(cube) {
      scene.remove(cube);
      cubes = cubes.filter(c => c !== cube);
      score++;
      scoreEl.innerText = `Score: ${score}`;
    }

    // Verifica gaze: um ray do centro da tela (0,0 em NDC)
    function checkGaze(frame) {
      // usamos raycaster setFromCamera com (0,0)
      raycaster.setFromCamera(new THREE.Vector2(0, 0), camera);
      const intersects = raycaster.intersectObjects(cubes, false);
      if (intersects.length > 0) {
        // remove o primeiro
        const cube = intersects[0].object;
        removeCube(cube);
      }
    }

    // render loop com hit-test + tentativa de usar depth-sensing para oclusão
    function animate() {
      renderer.setAnimationLoop((time, frame) => {
        // esconder dica assim que entrar na sessão AR
        const session = renderer.xr.getSession();
        if (session) {
          startHint.style.display = 'none';
        }

        if (frame) {
          const referenceSpace = renderer.xr.getReferenceSpace();
          const session = renderer.xr.getSession();

          // hit-test: request once
          if (!hitTestSourceRequested) {
            session.requestReferenceSpace('viewer').then((refSpace) => {
              session.requestHitTestSource({ space: refSpace }).then((source) => {
                hitTestSource = source;
              }).catch(err => {
                console.warn('requestHitTestSource falhou:', err);
              });
            }).catch(err => {
              console.warn('requestReferenceSpace(viewer) falhou:', err);
            });

            // tenta limpar hitTestSource quando a sessão terminar
            session.addEventListener('end', () => {
              hitTestSourceRequested = false;
              hitTestSource = null;
            });

            hitTestSourceRequested = true;
          }

          // atualizar reticle via hit-test
          if (hitTestSource) {
            const hitTestResults = frame.getHitTestResults(hitTestSource);
            if (hitTestResults.length > 0) {
              const hit = hitTestResults[0];
              const pose = hit.getPose(referenceSpace);
              if (pose) {
                reticle.visible = true;
                reticle.matrix.fromArray(pose.transform.matrix);
                // mover sombra
                const shadow = scene.getObjectByName("shadowPlane");
                if (shadow) {
                  shadow.visible = true;
                  shadow.position.set(pose.transform.position.x, pose.transform.position.y + 0.01, pose.transform.position.z);
                  const q = pose.transform.orientation;
                  shadow.quaternion.set(q.x, q.y, q.z, q.w);
                }
              } else {
                reticle.visible = false;
                const shadow = scene.getObjectByName("shadowPlane");
                if (shadow) shadow.visible = false;
              }
            } else {
              reticle.visible = false;
              const shadow = scene.getObjectByName("shadowPlane");
              if (shadow) shadow.visible = false;
            }
          }

          // Verifica gaze para remover cubo (apenas quando em AR)
          checkGaze(frame);

          // TENTA aplicar oclusão simples usando Depth API:
          // Estratégia: para cada cubo, projetamos para NDC, amostramos o depth map e comparamos distâncias.
          // Se depthReal < distanciaDoCubo (por exemplo, a um limiar), o cubo está atrás de um objeto real -> tornamos parcialmente invisível.
          try {
            const pose = frame.getViewerPose(referenceSpace);
            if (pose && pose.views && pose.views.length > 0) {
              const view = pose.views[0];

              // Para cada cubo, projetar e comparar
              for (let i = 0; i < cubes.length; i++) {
                const c = cubes[i];
                // transformar world -> NDC
                const pos = c.position.clone();
                pos.project(camera); // agora pos.x,pos.y em NDC [-1,1], pos.z é depth NDC
                const ndcX = pos.x;
                const ndcY = pos.y;

                // amostra depth (em metros) no ponto do mapa de profundidade
                const depthMeters = sampleDepthAt(frame, ndcX, ndcY);

                if (depthMeters !== null) {
                  // distância do camera ao cubo
                  const cameraPos = new THREE.Vector3();
                  camera.getWorldPosition(cameraPos);
                  const distToCube = cameraPos.distanceTo(c.position);

                  // Se a profundidade real for menor que a distância até o cubo -> algo real está na frente
                  if (depthMeters + 0.03 < distToCube) {
                    // esconder ou tornar semi-transparente
                    c.material.transparent = true;
                    c.material.opacity = 0.15;
                    c.userData.occluded = true;
                  } else {
                    if (c.userData.occluded) {
                      c.material.opacity = 1.0;
                      c.material.transparent = false;
                      c.userData.occluded = false;
                    }
                  }
                } else {
                  // sem depth info -> nada a fazer
                  if (c.userData && c.userData.occluded) {
                    c.material.opacity = 1.0;
                    c.material.transparent = false;
                    c.userData.occluded = false;
                  }
                }
              }
            }
          } catch (err) {
            // se algo quebrar ao tentar depth sampling, ignoramos (não deve interromper AR)
            // console.warn("Erro ao usar depth-sensing:", err);
          }
        }

        // Rotaciona levemente cubos para efeito visual (não afeta colocação)
        cubes.forEach(c => {
          c.rotation.x += 0.005;
          c.rotation.y += 0.01;
        });

        renderer.render(scene, camera);
      });
    }
  </script>
</body>
</html>
