<!DOCTYPE html>
<html lang="pt-BR">

<head>
  <meta charset="UTF-8">
  <title>VR Protótipo Interativo</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    #info {
      position: absolute;
      top: 10px;
      left: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      font-family: sans-serif;
      z-index: 1;
    }

    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      color: white;
      background: rgba(0, 0, 0, 0.5);
      padding: 5px 10px;
      font-family: sans-serif;
      z-index: 1;
    }
  </style>
</head>

<body>
  <button id="startCamera" style="
  position:absolute; top:50%; left:50%;
  transform:translate(-50%, -50%);
  z-index:2; padding:10px 20px;
  font-size:16px;
  ">Ativar Câmera</button>

  <div id="info">Mova o celular para girar a câmera e olhar para os cubos.</div>
  <div id="score">Score: 0</div>

  <script type="module">
    import 'https://unpkg.com/webxr-polyfill@latest/build/webxr-polyfill.module.js';
  </script>

<script type="module">
import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.152.0/build/three.module.js';
import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.152.0/examples/jsm/webxr/ARButton.js';

let camera, scene, renderer;
let hitTestSource = null;
let hitTestSourceRequested = false;

let reticle; // o "alvo" que marca a superfície detectada
let cubes = [];

// ----------------------------------------
// INIT
// ----------------------------------------
function init() {
  scene = new THREE.Scene();

  camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.01, 20);

  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
  renderer.setSize(window.innerWidth, window.innerHeight);
  renderer.xr.enabled = true;
  document.body.appendChild(renderer.domElement);

  document.body.appendChild(ARButton.createButton(renderer, {
    requiredFeatures: ["hit-test"]
  }));

  // Luz
  const light = new THREE.HemisphereLight(0xffffff, 0xbbbbff, 1);
  scene.add(light);

  // Retículo para mostrar a superfície
  reticle = new THREE.Mesh(
    new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
    new THREE.MeshBasicMaterial({ color: 0x00ff00 })
  );
  reticle.visible = false;
  scene.add(reticle);

  // Clique na tela coloca objetos
  window.addEventListener("click", () => {
    if (reticle.visible) {
      addCubeAt(reticle.position);
    }
  });
}

// ----------------------------------------
// ADICIONA CUBO NA POSIÇÃO DO RETÍCULO
// ----------------------------------------
function addCubeAt(pos) {
  const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
  const material = new THREE.MeshNormalMaterial();
  const cube = new THREE.Mesh(geometry, material);

  cube.position.copy(pos);
  cube.position.y += 0.1; // sobe um pouco para não ficar afundado
  scene.add(cube);
  cubes.push(cube);
}

// ----------------------------------------
// ANIMAÇÃO + HIT-TEST
// ----------------------------------------
function animate() {
  renderer.setAnimationLoop((timestamp, frame) => {
    
    if (frame) {
      const referenceSpace = renderer.xr.getReferenceSpace();
      const session = renderer.xr.getSession();

      // Solicita hit test apenas uma vez
      if (!hitTestSourceRequested) {
        session.requestReferenceSpace("viewer").then((refSpace) => {
          session.requestHitTestSource({ space: refSpace }).then((source) => {
            hitTestSource = source;
          });
        });

        hitTestSourceRequested = true;
      }

      if (hitTestSource) {
        const hitTestResults = frame.getHitTestResults(hitTestSource);

        if (hitTestResults.length > 0) {
          const hit = hitTestResults[0];
          const pose = hit.getPose(referenceSpace);

          reticle.visible = true;
          reticle.position.set(pose.transform.position.x, pose.transform.position.y, pose.transform.position.z);
          reticle.updateMatrixWorld(true);
        } else {
          reticle.visible = false;
        }
      }
    }

    renderer.render(scene, camera);
  });
}

init();
animate();
</script>

</body>

</html>