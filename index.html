<!doctype html>
<html lang="pt-BR">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>Cardboard WebGL Fisheye</title>
<style>
  html,body{height:100%;margin:0;background:#000;color:#fff;font-family:Inter,system-ui,sans-serif}
  #ui{position:fixed;left:12px;top:12px;z-index:50;display:flex;gap:8px}
  button{padding:8px 10px;border:0;border-radius:8px;background:#1e88e5;color:white;cursor:pointer}
  button.secondary{background:#455a64}
  #msg{position:fixed;left:12px;bottom:12px;background:rgba(0,0,0,0.35);padding:8px 10px;border-radius:8px;font-size:13px;z-index:70}
  canvas{display:block;width:100vw;height:100vh}
</style>
</head>
<body>
<div id="ui">
  <button id="btn-ar">Iniciar AR</button>
  <button id="btn-exit" class="secondary">Sair</button>
</div>
<div id="msg">Aguardando...</div>
<canvas id="glcanvas"></canvas>

<script>
// ---- helpers GL ----
function compileShader(gl, src, type){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
    throw new Error('Shader compile error: ' + gl.getShaderInfoLog(s));
  }
  return s;
}
function createProgram(gl, vsSrc, fsSrc){
  const vs = compileShader(gl, vsSrc, gl.VERTEX_SHADER);
  const fs = compileShader(gl, fsSrc, gl.FRAGMENT_SHADER);
  const p = gl.createProgram();
  gl.attachShader(p, vs);
  gl.attachShader(p, fs);
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS)){
    throw new Error('Program link error: ' + gl.getProgramInfoLog(p));
  }
  return p;
}

// ---- Shaders ----
const vertexSrc = `
attribute vec2 a_pos;
varying vec2 v_uv;
void main(){
  v_uv = a_pos * 0.5 + 0.5;
  gl_Position = vec4(a_pos, 0.0, 1.0);
}
`;

const fragmentSrc = `
precision mediump float;

uniform sampler2D u_texLeft;
uniform sampler2D u_texRight;

uniform float u_k1;
uniform float u_k2;
uniform float u_aspect;
uniform vec2  u_lensCenter;
uniform int   u_eye;

varying vec2 v_uv;

void main(){
    vec2 uv = vec2(v_uv.x, 1.0 - v_uv.y);

    vec2 centered = uv - u_lensCenter;
    centered.x *= u_aspect;

    float r = length(centered);
    float factor = 1.0 + u_k1*r*r + u_k2*r*r*r*r;

    vec2 distorted = centered * factor;
    distorted.x /= u_aspect;
    vec2 finalUV = distorted + u_lensCenter;

    if(finalUV.x < 0.0 || finalUV.x > 1.0 ||
       finalUV.y < 0.0 || finalUV.y > 1.0){
        gl_FragColor = vec4(0,0,0,1);
        return;
    }

    if(u_eye == 0)
        gl_FragColor = texture2D(u_texLeft, finalUV);
    else
        gl_FragColor = texture2D(u_texRight, finalUV);
}
`;

const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl', { antialias: true }) || canvas.getContext('experimental-webgl');

const program = createProgram(gl, vertexSrc, fragmentSrc);
gl.useProgram(program);

const a_pos = gl.getAttribLocation(program, 'a_pos');
const u_k1  = gl.getUniformLocation(program, 'u_k1');
const u_k2  = gl.getUniformLocation(program, 'u_k2');
const u_aspect = gl.getUniformLocation(program, 'u_aspect');
const u_lensCenter = gl.getUniformLocation(program, 'u_lensCenter');
const u_texLeft  = gl.getUniformLocation(program, 'u_texLeft');
const u_texRight = gl.getUniformLocation(program, 'u_texRight');
const u_eye      = gl.getUniformLocation(program, 'u_eye');

// bind texture units
gl.uniform1i(u_texLeft, 0);
gl.uniform1i(u_texRight, 1);

// Quad
const quad = new Float32Array([
  -1,-1,  1,-1,  -1,1,
  -1,1,   1,-1,   1,1
]);
const vbo = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, vbo);
gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
gl.enableVertexAttribArray(a_pos);
gl.vertexAttribPointer(a_pos, 2, gl.FLOAT, false, 0, 0);

// Video elements
const videoLeft = document.createElement('video');
videoLeft.autoplay = true;
videoLeft.playsInline = true;
videoLeft.muted = true;

const videoRight = document.createElement('video');
videoRight.autoplay = true;
videoRight.playsInline = true;
videoRight.muted = true;

const videoSingle = document.createElement('video');
videoSingle.autoplay = true;
videoSingle.playsInline = true;
videoSingle.muted = true;

// Textures
function makeTex(){
  const t = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, t);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return t;
}
const texLeft  = makeTex();
const texRight = makeTex();
const texSingle = makeTex();

let stream = null;
let running = false;

const msg = document.getElementById('msg');

// --- tentar abrir 2 câmeras traseiras ---
async function tryStereoCameras(){
  const devices = await navigator.mediaDevices.enumerateDevices();
  const cams = devices.filter(d => d.kind === "videoinput");
  const backs = cams.filter(c =>
    c.label.toLowerCase().includes("back") ||
    c.label.toLowerCase().includes("rear")
  );

  if(backs.length < 2) return null;

  try{
    const left = await navigator.mediaDevices.getUserMedia({
      video:{ deviceId: backs[0].deviceId }
    });
    const right = await navigator.mediaDevices.getUserMedia({
      video:{ deviceId: backs[1].deviceId }
    });
    return { left, right };
  }catch(e){
    return null;
  }
}

async function startAR(){
  msg.textContent = "Procurando 2 câmeras...";
  const stereo = await tryStereoCameras();

  if(stereo){
    videoLeft.srcObject  = stereo.left;
    videoRight.srcObject = stereo.right;
    stream = stereo;
    msg.textContent = "Estéreo REAL ativo";
    running = true;
    videoLeft.play(); videoRight.play();
    resizeAndLoop();
    return;
  }

  msg.textContent = "Só 1 câmera. Abrindo...";
  stream = await navigator.mediaDevices.getUserMedia({
    video:{ facingMode:"environment", width:{ideal:2560}, height:{ideal:1440} }
  });
  videoSingle.srcObject = stream;
  videoSingle.play();
  running = true;
  resizeAndLoop();
}

document.getElementById('btn-ar').onclick = startAR;
document.getElementById('btn-exit').onclick = () => {
  if(stream){
    if(stream.left) stream.left.getTracks().forEach(t=>t.stop());
    if(stream.right) stream.right.getTracks().forEach(t=>t.stop());
    if(stream.getTracks) stream.getTracks().forEach(t=>t.stop());
  }
  running = false;
  msg.textContent = "Parado";
};

function resizeCanvas(){
  const dpr = window.devicePixelRatio || 1;
  const w = innerWidth * dpr;
  const h = innerHeight * dpr;
  if(canvas.width!==w || canvas.height!==h){
    canvas.width = w; canvas.height = h;
  }
}

let K1 = 0.34;
let K2 = 0.55;
let ipd = 0.03;

function render(){
  if(!running){ requestAnimationFrame(render); return; }

  resizeCanvas();

  const w = canvas.width;
  const h = canvas.height;
  const eyeW = w/2;
  const eyeH = h;

  gl.viewport(0,0,w,h);
  gl.clearColor(0,0,0,1);
  gl.clear(gl.COLOR_BUFFER_BIT);

  if(stream.left && stream.right){
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texLeft);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,videoLeft);

      gl.activeTexture(gl.TEXTURE1);
      gl.bindTexture(gl.TEXTURE_2D, texRight);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,videoRight);
  }else{
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, texSingle);
      gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,videoSingle);
  }

  gl.uniform1f(u_k1, K1);
  gl.uniform1f(u_k2, K2);

  const leftCenter  = 0.25;
  const rightCenter = 0.75;

  // Left eye
  gl.viewport(0,0,eyeW,eyeH);
  gl.uniform1i(u_eye, 0);
  gl.uniform1f(u_aspect, 1.0);
  gl.uniform2f(u_lensCenter, leftCenter + ipd, 0.5);
  gl.drawArrays(gl.TRIANGLES,0,6);

  // Right eye
  gl.viewport(eyeW,0,eyeW,eyeH);
  gl.uniform1i(u_eye, stream.left ? 1 : 0);
  gl.uniform1f(u_aspect, 1.0);
  gl.uniform2f(u_lensCenter, rightCenter - ipd, 0.5);
  gl.drawArrays(gl.TRIANGLES,0,6);

  requestAnimationFrame(render);
}

function resizeAndLoop(){
  resizeCanvas();
  render();
}

window.setDistortion = (k1,k2)=>{K1=k1;K2=k2;};
window.setIPD=(v)=>{ipd=v;};

</script>
</body>
</html>
